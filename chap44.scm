;; Recursive-Descent Parsing
(require "./chap4")

(define (FIRST g alpha)
  (let1 prods (grammar-productions g)
	(let1 alpha-prod (filter (lambda (prod) (eq? alpha (grouped-production-head prod))) prods)
	  (if (null? alpha-prod) '()
		  (let1 elems (append-map (lambda (body)
									(let1 first-elem (car body)
									  (if (terminal? first-elem)
										  (list first-elem)
										  (FIRST g first-elem))))
								  (grouped-production-bodies (car alpha-prod)))
			(let1 ht (make-hash-table 'eq?)
			  (for-each (cut hash-table-put! ht <> #t) elems)
			  (hash-table-map ht (lambda (k v) k)))
			)))))

(define (FIRST&FOLLOW g)
  (let ([nonterminals (grammar-nonterminals g)]
		[prods (grammar-productions g)]
		[first-ht (make-hash-table 'eqv?)]
		[follow-ht (make-hash-table 'eqv?)])
	(define (FIRST alpha)
	  (or (hash-table-get first-ht alpha #f)
		  (let1 alpha-prod (filter (lambda (prod) (eq? alpha (grouped-production-head prod))) prods)
			(if (null? alpha-prod)
				(begin
				  (hash-table-put! first-ht alpha '())
				  '())
				(let1 elems (append-map (lambda (body)
										  (let1 first-elem (car body)
											(if (terminal? first-elem)
												(list first-elem)
												(FIRST first-elem))))
										(grouped-production-bodies (car alpha-prod)))
				  (let1 result (list->lset elems)
					(hash-table-put! first-ht alpha result)
					result)
				  )))))
	#;(print (map FIRST nonterminals))
	(values (lambda (alpha) (hash-table-get first-ht alpha '()))
			(lambda (A) (hash-table-get follow-ht A '())) )
	))
	
(define (FOLLOW g A)
  ;; A : nonterminal
  )

(define g_4_28 '((E  -> T E#)
				 (E# -> #\+ T E#  / :empty)
				 (T  -> F T#)
				 (T# -> #\* F T#  / :empty)
				 (F  -> #\( E #\) / <id>) ))

(use gauche.test)
(test-start "")
(let1 g (parse-grammar-desc g_4_28)
  (receive (FIRST FOLLOW) (FIRST&FOLLOW g)
	(test-section "FIRST()")
	(test* "FIRST(F)" '(#\( <id>) (FIRST 'F) lset-eq?)
	(test* "FIRST(T)" '(#\( <id>) (FIRST 'T) lset-eq?)
	(test* "FIRST(E)" '(#\( <id>) (FIRST 'E) lset-eq?)
	(test* "FIRST(E')" '(#\+ :empty) (FIRST 'E#) lset-eq?)
	(test* "FIRST(T')" '(#\* :empty) (FIRST 'T#) lset-eq?)
	(test-section "FOLLOW()")
	(test* "FOLLOW(E)" '(#\) :$) (FOLLOW 'E) lset-eq?)
	(test* "FOLLOW(E')" '(#\) :$) (FOLLOW 'E#) lset-eq?)
	(test* "FOLLOW(T)" '(#\+ #\) :$) (FOLLOW 'T) lset-eq?)
	(test* "FOLLOW(T')" '(#\+ #\) :$) (FOLLOW 'T#) lset-eq?)
	(test* "FOLLOW(F)" '(#\+ #\* #\) :$) (FOLLOW 'F) lset-eq?)
	))
(test-end)


